/* BloomFilter operations.
 *
 * My English is so poor! 
 * So I can't descript it by Engligsh,
 * And I'm also disinclined to descript it by Chinese.
 * So if you couldn't understand what's this,
 * You can beg God to help you.   
 */

#include "server.h"
#include <sys/time.h>
#include <assert.h>

/* 主线程与BF HASH计算线程通信的管道描述符 */
int g_bfHashReadFd;
int g_bfHashWriteFd;

/* Take From bitopt.c 
 * To Find the key when bfset, if the key not exist then create */
extern robj *lookupStringForBitCommand(client *c, size_t maxbit);
extern void rdbRemoveTempFile(pid_t childpid);

const unsigned int bfseed[] =
{
    0xAAAAAAAA, 0x55555555, 0x33333333, 0xCCCCCCCC,
    0x66666666, 0x99999999, 0xB5B5B5B5, 0x4B4B4B4B,
    0xAA55AA55, 0x55335533, 0x33CC33CC, 0xCC66CC66,
    0x66996699, 0x99B599B5, 0xB54BB54B, 0x4BAA4BAA,
    0xAA33AA33, 0x55CC55CC, 0x33663366, 0xCC99CC99,
    0x66B566B5, 0x994B994B, 0xB5AAB5AA, 0xAAAAAA33,
    0x555555CC, 0x33333366, 0xCCCCCC99, 0x666666B5,
    0x9999994B, 0xB5B5B5AA, 0xFFFFFFFF, 0xFFFF0000
};

#define BF_MAX_CUSTOM_KEYS  10240
unsigned char g_hashThreadStop = 0;
//用于发送分布式计算请求的结构体
struct STHashRequest {
    unsigned int    version;
    unsigned int    argc;
    unsigned int    hashcnt;
    
    /* bfget bfset使用 */
    robj**          objStrs;
    /*******************/

    /* bfbget bfbset使用 */
    unsigned int    keyLen;
    robj*           objOne;
    /*********************/
} __attribute__ ((packed));

//用于分布式计算存储hash结果的结构体
struct STHashResult {
    volatile unsigned int   version;                                                            //当前版本, 从1开始递增
    volatile unsigned int   result[BF_MAX_CUSTOM_KEYS][(sizeof(bfseed) / sizeof(bfseed[0])) * 2]; //[rversion][result]
};
static volatile struct STHashResult g_stHashResult = {0, {{0}}};

static inline unsigned int bfhash(const unsigned char* str, size_t len, unsigned int hash)
{
    for (size_t i = 0; i < len; i++)
    {
        hash ^= 
            (((i & 1) == 0) ? 
                ((hash <<  7) ^ (str[i] * (hash >> 3))) 
                : (~(((hash << 11) + str[i]) ^(hash >> 5))));
    }

    return hash;
}

/* BF HASH Calculate Thread Function */
void* BFHashCalcInThread(void* arg)
{
    arg = NULL;
    unsigned int    preArgc = 0;
    robj**          preObjStrs = NULL;
    robj*           preObjOne = NULL;
    struct STHashRequest req;
    
    while (!g_hashThreadStop)
    {
        ssize_t recvd = read(g_bfHashReadFd, &req, sizeof(req));
        if (recvd <= 0)
        {
            if (errno == EAGAIN)
            {
                continue;
            }
            else
            {
                fprintf(stderr, "thread exit! fd:%d, ret:%ld, error:%s\n",
                        g_bfHashReadFd, recvd, strerror(errno));
                serverLog(LL_WARNING, "thread exit! fd:%d, ret:%ld, error:%s\n",
                        g_bfHashReadFd, recvd, strerror(errno));
                rdbRemoveTempFile(getpid());
                exit(1);
            }
        }

        assert(recvd == sizeof(req));
        
        server.bf_threadused++;

        if (preObjOne)
        {
            decrRefCount(preObjOne);
        }
        else
        {
            for (int i = 0; i < (int)preArgc; i++)
                if (preObjStrs[i] != NULL)
                    decrRefCount(preObjStrs[i]);
            if (preObjStrs)
                zfree(preObjStrs);
        }

        preArgc = req.argc;
        preObjStrs = req.objStrs;
        preObjOne = req.objOne;
                
        if (req.version < g_stHashResult.version)
            continue;
        if (req.hashcnt > (int)(sizeof(bfseed) / sizeof(bfseed[0]))
                || req.hashcnt <= 0)
            continue;
 
        for (int i = 0; i < (int)req.argc && i < (int)BF_MAX_CUSTOM_KEYS; i++)
        {
            if (g_stHashResult.result[i][0] >= req.version)
            {
                continue;
            }
            
            for (int j = 0; j < (int)req.hashcnt; j++)
            {
                if (g_stHashResult.result[i][j << 1] >= req.version)
                {
                    break;
                }
                
                server.bf_hashcalcbythread++;
                unsigned int val = bfhash(req.objOne ? 
                        req.objOne->ptr + (i * req.keyLen) : req.objStrs[i]->ptr, 
                        req.objOne ? keyLen : sdslen(req.objStrs[i]->ptr), bfseed[j]);
                if (g_stHashResult.result[i][j << 1] < req.version)
                {
                    g_stHashResult.result[i][(j << 1) + 1] = val;
                    g_stHashResult.result[i][(j << 1)] = req.version;

                    server.bf_threadsethash++;
                }
                else
                {
                    break;
                }
            }
        }
    }

    return NULL;   
}

/* BFCONF 
 *          thr_threshold count
 *          clearstat*/
void bfconfCommand(client *c) 
{
    if (!strcasecmp(c->argv[1]->ptr, "thrthreshold") && c->argc == 3) 
    {
        long long threshold;

        if (getLongLongFromObject(c->argv[2], &threshold) != C_OK || threshold < 0) {
            addReplyErrorFormat(c,"Invalid THREAD THRESHOLD specified: %s",
                                (char*)c->argv[2]->ptr);
            return ;
        }

        server.bf_thrthreshold = (unsigned long long)threshold;
        addReply(c,shared.ok);
        return ;
    }
    else if (!strcasecmp(c->argv[1]->ptr, "clearstat"))
    {
        server.bf_gethit = 0;
        server.bf_getnohit = 0;
        server.bf_sethit = 0;
        server.bf_setnohit = 0;
        server.bf_threadused = 0,
        server.bf_hashcalcbythread = 0;
        server.bf_threadsethash = 0;
        addReply(c,shared.ok);
        return ;
    }

    addReplyErrorFormat(c, "Only Support: thrthreshold count");
    return ;
}

/* BFGET key hashcnt customKey1 [customKey2 ...]*/
void bfgetCommand(client *c) {
    robj *o;
    char llbuf[32];
    size_t bitoffset;
    size_t byte, bit;
    size_t bitval = 0;

    int haskey = 1;
    int hasAssistant = 0;
    int iarg = 0;
    int seedNum = (int)sizeof(bfseed) / sizeof(bfseed[0]);
    long hashNum = 0;

#ifdef _SZ_DEBUG_
    struct timeval tv1, tv2, tv3, tv4, tv5, tvsb, tvse;
    gettimeofday(&tv1,NULL);
#endif

    if ((o = lookupKeyRead(c->db, c->argv[1])) == NULL ||
        checkType(c,o,OBJ_STRING)) 
    {
        haskey = 0;
    }

#ifdef _SZ_DEBUG_
    gettimeofday(&tv2,NULL);
#endif

    if (getLongFromObjectOrReply(c, c->argv[2], &hashNum, NULL) != C_OK
        || hashNum <= 0 || hashNum > seedNum)
    {
        addReplyError(c, "hash number is invalid");
        return ;   
    }
    
#ifdef _SZ_DEBUG_
    gettimeofday(&tv3,NULL);
#endif

    //发送hash计算请求, 当customKey的个数大于27个时，才启用辅助线程 ()
    if (haskey && (c->argc - 3) > (int)server.bf_thrthreshold)
    {
        struct STHashRequest req;
        req.version = ++g_stHashResult.version;
        req.argc = c->argc - 3;
        req.keyLen = 0;
        req.objOne = NULL;
        req.hashcnt = hashNum;
        req.objStrs = zmalloc(sizeof(robj*) * req.argc);
        for (int i = 3; i < c->argc; i++)
            req.objStrs[i - 3] = c->argv[i];

#ifdef _SZ_DEBUG_
        gettimeofday(&tvsb,NULL);
#endif
        if (write(g_bfHashWriteFd, &req, sizeof(req)) > 0)
        {
#ifdef _SZ_DEBUG_
            gettimeofday(&tvse,NULL);
#endif
            hasAssistant = 1;
            for (int i = 3; i < c->argc; i++)
                incrRefCount(c->argv[i]);
        }
        else
        {
#ifdef _SZ_DEBUG_
            gettimeofday(&tvse,NULL);
#endif
            zfree(req.objStrs);
        }
    }

#ifdef _SZ_DEBUG_
    gettimeofday(&tv4,NULL);
#endif

    void* replyLen = addDeferredMultiBulkLength(c);
    int replyElements = 0;
    for (iarg = 3; iarg < c->argc; iarg++)
    {
        if (haskey == 0)
        {
            addReply(c, shared.czero);
            replyElements++;
            continue;
        }

        int customKeySeted = 1;
        for (int i = 0; i < hashNum; i++)
        {
            if (hasAssistant && iarg - 3 < BF_MAX_CUSTOM_KEYS 
                    && g_stHashResult.result[iarg - 3][i << 1] == g_stHashResult.version)
            {
                bitoffset = g_stHashResult.result[iarg - 3][(i << 1) + 1];
                server.bf_gethit++;
            }
            else
            {
                if (hasAssistant && iarg - 3 < BF_MAX_CUSTOM_KEYS)
                    g_stHashResult.result[iarg - 3][i << 1] = g_stHashResult.version;

                bitoffset = bfhash(c->argv[iarg]->ptr, sdslen(c->argv[iarg]->ptr), bfseed[i]);
                server.bf_getnohit++;
            }
            
            //fprintf(stderr, "custom key[%d]:%s, bitoffset:%lu\n", i, c->argv[iarg]->ptr, bitoffset);
            //bitoffset = bitoffset % (4 * 1024 * 1024 * 1024);
            byte = bitoffset >> 3;
            bit = 7 - (bitoffset & 0x7);
            if (sdsEncodedObject(o)) 
            {
                if (byte < sdslen(o->ptr))
                    bitval = ((uint8_t*)o->ptr)[byte] & (1 << bit);
            } 
            else 
            {
                if (byte < (size_t)ll2string(llbuf,sizeof(llbuf),(long)o->ptr))
                    bitval = llbuf[byte] & (1 << bit);
            }
            
            if (!bitval)
            {
                if (hasAssistant && iarg - 3 < BF_MAX_CUSTOM_KEYS)
                    for (; i < hashNum; i++)
                        g_stHashResult.result[iarg - 3][i << 1] = g_stHashResult.version;

                customKeySeted = 0;
                break;
            }
        }
        addReply(c, customKeySeted ? shared.cone : shared.czero);
        replyElements++;
    }
    setDeferredMultiBulkLength(c, replyLen, replyElements);

#ifdef _SZ_DEBUG_
    gettimeofday(&tv5,NULL);
    fprintf(stderr, "BFGET| diffall=%lu, difflook=%lu, diffhashcnt=%lu, diffsend=%lu, diffrs=%lu, diffcalc=%lu\n",
            (tv5.tv_sec - tv1.tv_sec) * 1000000 + (tv5.tv_usec - tv1.tv_usec) / 1
            , (tv2.tv_sec - tv1.tv_sec) * 1000000 + (tv2.tv_usec - tv1.tv_usec) / 1
            , (tv3.tv_sec - tv2.tv_sec) * 1000000 + (tv3.tv_usec - tv2.tv_usec) / 1
            , (tv4.tv_sec - tv3.tv_sec) * 1000000 + (tv4.tv_usec - tv3.tv_usec) / 1
            , (tvse.tv_sec - tvsb.tv_sec) * 1000000 + (tvse.tv_usec - tvsb.tv_usec) / 1
            , (tv5.tv_sec - tv4.tv_sec) * 1000000 + (tv5.tv_usec - tv4.tv_usec) / 1);
#endif

}

/* BFSET key hashcnt customKey1 [customKey2 ...]*/
void bfsetCommand(client *c) {
    robj *o;
    size_t bitoffset;
    size_t byte, bit;
    int byteval, bitval;
    long on = 1;

    int hasAssistant = 0;
    int iarg = 0;
    int seedNum = (int)sizeof(bfseed) / sizeof(bfseed[0]);
    long hashNum = 0;

#ifdef _SZ_DEBUG_
    struct timeval tv1, tv2, tv3, tv4, tv5;
    gettimeofday(&tv1,NULL);
#endif

    if ((o = lookupStringForBitCommand(c, 4L * 1024L * 1024L * 1024L - 1)) == NULL) 
    {
        return ;
    }

#ifdef _SZ_DEBUG_
    gettimeofday(&tv2,NULL);
#endif

    if (getLongFromObjectOrReply(c, c->argv[2], &hashNum, NULL) != C_OK
        || hashNum <= 0 || hashNum > seedNum)
    {
        addReplyError(c, "hash number is invalid");
        return ;   
    }

#ifdef _SZ_DEBUG_
    gettimeofday(&tv3,NULL);
#endif

    //发送hash计算请求, 当customKey的个数大于27个时，才启用辅助线程
    if (c->argc - 3 > (int)server.bf_thrthreshold)
    {
        struct STHashRequest req;
        req.version = ++g_stHashResult.version;
        req.argc = c->argc - 3;
        req.keyLen = 0;
        req.objOne = NULL;
        req.hashcnt = hashNum;
        req.objStrs = zmalloc(sizeof(robj*) * req.argc);
        for (int i = 3; i < c->argc; i++)
            req.objStrs[i - 3] = c->argv[i];
        if (write(g_bfHashWriteFd, &req, sizeof(req)) > 0)
        {
            hasAssistant = 1;
            for (int i = 3; i < c->argc; i++)
                incrRefCount(c->argv[i]);
        }
        else
        {
            zfree(req.objStrs);
        }
    }
    
#ifdef _SZ_DEBUG_
    gettimeofday(&tv4,NULL);
#endif

    void* replyLen = addDeferredMultiBulkLength(c);
    int replyElements = 0;
    for (iarg = 3; iarg < c->argc; iarg++)
    {
        int customKeySeted = 1;
        for (int i = 0; i < hashNum; i++)
        {
            if (hasAssistant && iarg - 3 < BF_MAX_CUSTOM_KEYS
                    && g_stHashResult.result[iarg - 3][i << 1] == g_stHashResult.version)
            {
                server.bf_sethit++;
                bitoffset = g_stHashResult.result[iarg - 3][(i << 1) + 1];
            }
            else
            {
                if (iarg - 3 < BF_MAX_CUSTOM_KEYS)
                    g_stHashResult.result[iarg - 3][i << 1] = g_stHashResult.version;
                bitoffset = bfhash(c->argv[iarg]->ptr, sdslen(c->argv[iarg]->ptr), bfseed[i]);
                server.bf_setnohit++;
            }
            //fprintf(stderr, "custom key[%d]:%s, bitoffset:%lu\n", i, c->argv[iarg]->ptr, bitoffset);
            //bitoffset = bitoffset % (4 * 1024 * 1024 * 1024);

            /* Get current values */
            byte = bitoffset >> 3;
            byteval = ((uint8_t*)o->ptr)[byte];
            bit = 7 - (bitoffset & 0x7);
            bitval = byteval & (1 << bit);
            if (!bitval)
            {
                customKeySeted = 0;
            }

            /* Update byte with new bit value and return original value */
            byteval &= ~(1 << bit);
            byteval |= ((on & 0x1) << bit);
            ((uint8_t*)o->ptr)[byte] = byteval;
        }
        addReply(c, customKeySeted ? shared.cone : shared.czero);
        replyElements++;
    }
    setDeferredMultiBulkLength(c, replyLen, replyElements);
    
    signalModifiedKey(c->db,c->argv[1]);
    notifyKeyspaceEvent(NOTIFY_STRING,"bfset",c->argv[1],c->db->id);
    server.dirty++;

#ifdef _SZ_DEBUG_
    gettimeofday(&tv5,NULL);
    fprintf(stderr, "BFSET| diffall=%lu, difflook=%lu, diffhashcnt=%lu, diffsend=%lu, diffcalc=%lu\n",
            (tv5.tv_sec - tv1.tv_sec) * 1000000 + (tv5.tv_usec - tv1.tv_usec) / 1
            , (tv2.tv_sec - tv1.tv_sec) * 1000000 + (tv2.tv_usec - tv1.tv_usec) / 1
            , (tv3.tv_sec - tv2.tv_sec) * 1000000 + (tv3.tv_usec - tv2.tv_usec) / 1
            , (tv4.tv_sec - tv3.tv_sec) * 1000000 + (tv4.tv_usec - tv3.tv_usec) / 1
            , (tv5.tv_sec - tv4.tv_sec) * 1000000 + (tv5.tv_usec - tv4.tv_usec) / 1);
#endif
}

/* BFBGET key hashcnt customKeycnt customKeyLen customKeyBlock */
void bfbgetCommand(client *c) {
    robj *o;
    char llbuf[32];
    size_t bitoffset;
    size_t byte, bit;
    size_t bitval = 0;

    int haskey = 1;
    int hasAssistant = 0;
    int seedNum = (int)sizeof(bfseed) / sizeof(bfseed[0]);
    long hashNum = 0;
    long keyCnt = 0;
    long keyLen = 0;
    
    static uint8_t reply[BF_MAX_CUSTOM_KEYS] = {0};

#ifdef _SZ_DEBUG_
    struct timeval tv1, tv2, tv3, tv4, tv5, tvsb, tvse;
    gettimeofday(&tv1,NULL);
#endif

    if ((o = lookupKeyRead(c->db, c->argv[1])) == NULL ||
        checkType(c,o,OBJ_STRING)) 
    {
        haskey = 0;
    }

#ifdef _SZ_DEBUG_
    gettimeofday(&tv2,NULL);
#endif

    if (getLongFromObjectOrReply(c, c->argv[2], &hashNum, NULL) != C_OK
        || hashNum <= 0 || hashNum > seedNum)
    {
        addReplyError(c, "hash number is invalid");
        return ;   
    }

    if (getLongFromObjectOrReply(c, c->argv[3], &keyCnt, NULL) != C_OK)
    {
        addReplyError(c, "key count is invalid");
        return ;   
    }

    if (keyCnt > BF_MAX_CUSTOM_KEYS)
    {
        addReplyError(c, "too mange key");
        return ;
    }
    
    if (getLongFromObjectOrReply(c, c->argv[4], &keyLen, NULL) != C_OK)
    {
        addReplyError(c, "key length is invalid");
        return ;   
    } 

    if (sdslen(c->argv[5]->ptr) != (keyCnt * keyLen))
    {
        addReplyError(c, "keycnt and keylen not match keyblock");
        return ; 
    }

#ifdef _SZ_DEBUG_
    gettimeofday(&tv3,NULL);
#endif

    //发送hash计算请求, 当customKey的个数大于27个时，才启用辅助线程 ()
    if (haskey && keyCnt > (int)server.bf_thrthreshold)
    {
        struct STHashRequest req;
        req.version = ++g_stHashResult.version;
        req.argc = keyCnt;
        req.keyLen = keyLen;
        req.objOne = c->argv[5];
        req.hashcnt = hashNum;
        req.objStrs = NULL;

#ifdef _SZ_DEBUG_
        gettimeofday(&tvsb,NULL);
#endif
        if (write(g_bfHashWriteFd, &req, sizeof(req)) > 0)
        {
#ifdef _SZ_DEBUG_
            gettimeofday(&tvse,NULL);
#endif
            hasAssistant = 1;
            incrRefCount(c->argv[5]);
        }
        else
        {
#ifdef _SZ_DEBUG_
            gettimeofday(&tvse,NULL);
#endif
        }
    }

#ifdef _SZ_DEBUG_
    gettimeofday(&tv4,NULL);
#endif

    static uint8_t 
    for (int iarg = 0; iarg < keyCnt; iarg++)
    {
        if (haskey == 0)
        {
            reply[iarg] = 0; 
            continue;
        }

        uint8_t customKeySeted = 1;
        for (int i = 0; i < hashNum; i++)
        {
            if (hasAssistant 
                    && g_stHashResult.result[iarg][i << 1] == g_stHashResult.version)
            {
                bitoffset = g_stHashResult.result[iarg][(i << 1) + 1];
                server.bf_gethit++;
            }
            else
            {
                if (hasAssistant)
                    g_stHashResult.result[iarg][i << 1] = g_stHashResult.version;

                bitoffset = bfhash(c->argv[5]->ptr + (iarg * keyLen), keyLen, bfseed[i]);
                server.bf_getnohit++;
            }
            
            //fprintf(stderr, "custom key[%d]:%s, bitoffset:%lu\n", i, c->argv[iarg]->ptr, bitoffset);
            //bitoffset = bitoffset % (4 * 1024 * 1024 * 1024);
            byte = bitoffset >> 3;
            bit = 7 - (bitoffset & 0x7);
            if (sdsEncodedObject(o)) 
            {
                if (byte < sdslen(o->ptr))
                    bitval = ((uint8_t*)o->ptr)[byte] & (1 << bit);
            } 
            else 
            {
                if (byte < (size_t)ll2string(llbuf,sizeof(llbuf),(long)o->ptr))
                    bitval = llbuf[byte] & (1 << bit);
            }
            
            if (!bitval)
            {
                if (hasAssistant)
                    for (; i < hashNum; i++)
                        g_stHashResult.result[iarg][i << 1] = g_stHashResult.version;

                customKeySeted = 0;
                break;
            }
        }

        reply[iarg] = customKeySeted; 
    }

    addReplyString(c, reply, keyCnt);

#ifdef _SZ_DEBUG_
    gettimeofday(&tv5,NULL);
    fprintf(stderr, "BFBGET| diffall=%lu, difflook=%lu, diffhashcnt=%lu, diffsend=%lu, diffrs=%lu, diffcalc=%lu\n",
            (tv5.tv_sec - tv1.tv_sec) * 1000000 + (tv5.tv_usec - tv1.tv_usec) / 1
            , (tv2.tv_sec - tv1.tv_sec) * 1000000 + (tv2.tv_usec - tv1.tv_usec) / 1
            , (tv3.tv_sec - tv2.tv_sec) * 1000000 + (tv3.tv_usec - tv2.tv_usec) / 1
            , (tv4.tv_sec - tv3.tv_sec) * 1000000 + (tv4.tv_usec - tv3.tv_usec) / 1
            , (tvse.tv_sec - tvsb.tv_sec) * 1000000 + (tvse.tv_usec - tvsb.tv_usec) / 1
            , (tv5.tv_sec - tv4.tv_sec) * 1000000 + (tv5.tv_usec - tv4.tv_usec) / 1);
#endif

}

/* BFBSET key hashcnt customKeyLen customKeyBlock */
void bfsetCommand(client *c) {
    robj *o;
    size_t bitoffset;
    size_t byte, bit;
    int byteval, bitval;
    long on = 1;

    int hasAssistant = 0;
    int iarg = 0;
    int seedNum = (int)sizeof(bfseed) / sizeof(bfseed[0]);
    long hashNum = 0;
    long keyCnt = 0;
    long keyLen = 0;

#ifdef _SZ_DEBUG_
    struct timeval tv1, tv2, tv3, tv4, tv5;
    gettimeofday(&tv1,NULL);
#endif

    if ((o = lookupStringForBitCommand(c, 4L * 1024L * 1024L * 1024L - 1)) == NULL) 
    {
        return ;
    }

#ifdef _SZ_DEBUG_
    gettimeofday(&tv2,NULL);
#endif

    if (getLongFromObjectOrReply(c, c->argv[2], &hashNum, NULL) != C_OK
        || hashNum <= 0 || hashNum > seedNum)
    {
        addReplyError(c, "hash number is invalid");
        return ;   
    }
    
    if (getLongFromObjectOrReply(c, c->argv[3], &keyLen, NULL) != C_OK)
    {
        addReplyError(c, "key length is invalid");
        return ;   
    } 

    if (!keyLen || sdslen(c->argv[4]->ptr) % keyLen != 0)
    {
        addReplyError(c, "keylen not match keyblock");
        return ; 
    }
    keyCnt = sdslen(c->argv[4]->ptr) / keyLen;

    if (keyCnt > BF_MAX_CUSTOM_KEYS)
    {
        addReplyError(c, "too mange key");
        return ;
    }

#ifdef _SZ_DEBUG_
    gettimeofday(&tv3,NULL);
#endif

    //发送hash计算请求, 当customKey的个数大于27个时，才启用辅助线程
    if (keyCnt > (int)server.bf_thrthreshold)
    {
        struct STHashRequest req;
        req.version = ++g_stHashResult.version;
        req.argc = keyCnt;
        req.keyLen = keyLen;
        req.objOne = c->argv[4];
        req.hashcnt = hashNum;
        req.objStrs = zmalloc(sizeof(robj*) * req.argc);
        for (int i = 3; i < c->argc; i++)
            req.objStrs[i - 3] = c->argv[i];
        if (write(g_bfHashWriteFd, &req, sizeof(req)) > 0)
        {
            hasAssistant = 1;
            for (int i = 3; i < c->argc; i++)
                incrRefCount(c->argv[i]);
        }
        else
        {
            zfree(req.objStrs);
        }
    }
    
#ifdef _SZ_DEBUG_
    gettimeofday(&tv4,NULL);
#endif

    void* replyLen = addDeferredMultiBulkLength(c);
    int replyElements = 0;
    for (iarg = 3; iarg < c->argc; iarg++)
    {
        int customKeySeted = 1;
        for (int i = 0; i < hashNum; i++)
        {
            if (hasAssistant && iarg - 3 < BF_MAX_CUSTOM_KEYS
                    && g_stHashResult.result[iarg - 3][i << 1] == g_stHashResult.version)
            {
                server.bf_sethit++;
                bitoffset = g_stHashResult.result[iarg - 3][(i << 1) + 1];
            }
            else
            {
                if (iarg - 3 < BF_MAX_CUSTOM_KEYS)
                    g_stHashResult.result[iarg - 3][i << 1] = g_stHashResult.version;
                bitoffset = bfhash(c->argv[iarg]->ptr, sdslen(c->argv[iarg]->ptr), bfseed[i]);
                server.bf_setnohit++;
            }
            //fprintf(stderr, "custom key[%d]:%s, bitoffset:%lu\n", i, c->argv[iarg]->ptr, bitoffset);
            //bitoffset = bitoffset % (4 * 1024 * 1024 * 1024);

            /* Get current values */
            byte = bitoffset >> 3;
            byteval = ((uint8_t*)o->ptr)[byte];
            bit = 7 - (bitoffset & 0x7);
            bitval = byteval & (1 << bit);
            if (!bitval)
            {
                customKeySeted = 0;
            }

            /* Update byte with new bit value and return original value */
            byteval &= ~(1 << bit);
            byteval |= ((on & 0x1) << bit);
            ((uint8_t*)o->ptr)[byte] = byteval;
        }
        addReply(c, customKeySeted ? shared.cone : shared.czero);
        replyElements++;
    }
    setDeferredMultiBulkLength(c, replyLen, replyElements);
    
    signalModifiedKey(c->db,c->argv[1]);
    notifyKeyspaceEvent(NOTIFY_STRING,"bfset",c->argv[1],c->db->id);
    server.dirty++;

#ifdef _SZ_DEBUG_
    gettimeofday(&tv5,NULL);
    fprintf(stderr, "BFSET| diffall=%lu, difflook=%lu, diffhashcnt=%lu, diffsend=%lu, diffcalc=%lu\n",
            (tv5.tv_sec - tv1.tv_sec) * 1000000 + (tv5.tv_usec - tv1.tv_usec) / 1
            , (tv2.tv_sec - tv1.tv_sec) * 1000000 + (tv2.tv_usec - tv1.tv_usec) / 1
            , (tv3.tv_sec - tv2.tv_sec) * 1000000 + (tv3.tv_usec - tv2.tv_usec) / 1
            , (tv4.tv_sec - tv3.tv_sec) * 1000000 + (tv4.tv_usec - tv3.tv_usec) / 1
            , (tv5.tv_sec - tv4.tv_sec) * 1000000 + (tv5.tv_usec - tv4.tv_usec) / 1);
#endif
}
